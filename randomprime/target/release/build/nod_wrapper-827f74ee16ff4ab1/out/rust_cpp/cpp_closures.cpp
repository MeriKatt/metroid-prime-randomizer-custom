
/* THIS FILE IS GENERATED BY rust-cpp. DO NOT EDIT */

#include "stdint.h" // For {u}intN_t
#include <new> // For placement new
#include <cstdlib> // For abort
#include <type_traits>
#include <utility>

namespace rustcpp {

// We can't just pass or return any type from extern "C" rust functions (because the call
// convention may differ between the C++ type, and the Rust type).
// So we make sure to pass trivial structure that only contains a pointer to the object we want to
// pass. The constructor of these helper class contains a 'container' of the right size which will
// be allocated on the stack.
template<typename T> struct return_helper {
    struct container {
#if defined (_MSC_VER) && (_MSC_VER + 0 < 1900)
        char memory[sizeof(T)];
        ~container() { reinterpret_cast<T*>(this)->~T(); }
#else
        // The fact that it is in an union means it is properly sized and aligned, but we have
        // to call the destructor and constructor manually
        union { T memory; };
        ~container() { memory.~T(); }
#endif
        container() {}
    };
    const container* data;
    return_helper(int, const container &c = container()) : data(&c) { }
};

template<typename T> struct argument_helper {
    using type = const T&;
};
template<typename T> struct argument_helper<T&> {
    T &ref;
    argument_helper(T &x) : ref(x) {}
    using type = argument_helper<T&> const&;
};

template<typename T>
typename std::enable_if<std::is_copy_constructible<T>::value>::type copy_helper(const void *src, void *dest)
{ new (dest) T (*static_cast<T const*>(src)); }
template<typename T>
typename std::enable_if<!std::is_copy_constructible<T>::value>::type copy_helper(const void *, void *)
{ std::abort(); }
template<typename T>
typename std::enable_if<std::is_default_constructible<T>::value>::type default_helper(void *dest)
{ new (dest) T(); }
template<typename T>
typename std::enable_if<!std::is_default_constructible<T>::value>::type default_helper(void *)
{ std::abort(); }

template<typename T> int compare_helper(const T &a, const T&b, int cmp) {
    switch (cmp) {
        using namespace std::rel_ops;
        case 0:
            if (a < b)
                return -1;
            if (b < a)
                return 1;
            return 0;
        case -2: return a < b;
        case 2: return a > b;
        case -1: return a <= b;
        case 1: return a >= b;
    }
    std::abort();
}
}

#define RUST_CPP_CLASS_HELPER(HASH, ...) \
    extern "C" { \
    void __cpp_destructor_##HASH(void *ptr) { typedef __VA_ARGS__ T; static_cast<T*>(ptr)->~T(); } \
    void __cpp_copy_##HASH(const void *src, void *dest) { rustcpp::copy_helper<__VA_ARGS__>(src, dest); } \
    void __cpp_default_##HASH(void *dest) { rustcpp::default_helper<__VA_ARGS__>(dest); } \
    }

#line 45 "src/lib.rs"
       
    #include <nod/nod.hpp>

    struct FileWrapper
    {
        std::shared_ptr<nod::DiscBase> disc;
        nod::Node &file;

        uint64_t read_bytes(uint64_t offset, uint64_t buf_length, uint8_t *buf)
        {
            try {
                auto stream = this->file.beginReadStream(offset);
                return stream->read(buf, buf_length);
            } catch (...) {
                return 0;
            }
        }

        FileWrapper(std::shared_ptr<nod::DiscBase> disc_, nod::Node &file_)
            : disc(std::move(disc_)), file(file_)
        { }
    };

    struct DiscWrapper
    {
        std::shared_ptr<nod::DiscBase> disc;

        static DiscWrapper* create(nod::SystemChar *disc_path, const char **err_msg)
        {
            try {
                bool is_wii;
                std::unique_ptr<nod::DiscBase> disc = nod::OpenDiscFromImage(disc_path, is_wii);
                if (!disc) {
                    *err_msg = "Failed to open disc";
                    return 0;
                }

                nod::IPartition* partition = disc->getDataPartition();
                if (!partition) {
                    *err_msg = "Failed to find data partition";
                    return 0;
                }

                return new DiscWrapper { std::shared_ptr<nod::DiscBase>(disc.release()) };
            } catch (...) {
                *err_msg = "Unknown error";
                return 0;
            }
        }

        FileWrapper* open_file(const char *file_name)
        {
            try {
                nod::IPartition* partition = this->disc->getDataPartition();
                if (!partition) {
                    return 0;
                }

                nod::Node &root = partition->getFSTRoot();
                nod::Node *found = nullptr;
                auto it_end = root.rawEnd();
                for(auto it = root.rawBegin(); it != it_end; ++it) {
                    if(it->getName() == file_name) {
                        found = &*it;
                        break;
                    }
                }

                if(!found) {
                    return 0;
                }

                return new FileWrapper(this->disc, *found);
            } catch (...) {
                return 0;
            }
        }
    };


#line 265 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

static inline DiscWrapper* __cpp_closure_9843562945469222702_impl(nod::SystemChar* const& disc_path, const char ** const& err_msg) {
#line 138 "src/lib.rs"
                                                            
            return DiscWrapper::create(disc_path, err_msg);
        
}
extern "C" {
void __cpp_closure_9843562945469222702(nod::SystemChar* const& disc_path, const char ** const& err_msg, void* __result) {
    ::new(__result) (DiscWrapper*)(__cpp_closure_9843562945469222702_impl(disc_path, err_msg));
}
}
#line 265 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

static inline FileWrapper* __cpp_closure_2166181833509409529_impl(DiscWrapper* const& self_ptr, const char* const& file_name_ptr) {
#line 159 "src/lib.rs"
                                                            
            return self_ptr->open_file(file_name_ptr);
        
}
extern "C" {
void __cpp_closure_2166181833509409529(DiscWrapper* const& self_ptr, const char* const& file_name_ptr, void* __result) {
    ::new(__result) (FileWrapper*)(__cpp_closure_2166181833509409529_impl(self_ptr, file_name_ptr));
}
}
#line 246 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

extern "C" {
void __cpp_closure_15079480375502973842(DiscWrapper* const& p) {
#line 176 "src/lib.rs"
                                           
            delete p;
        
}
}
#line 265 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

static inline uint64_t __cpp_closure_14131938600352405202_impl(FileWrapper* const& p, uint64_t const& offset, uint64_t const& buf_len, uint8_t* const& buf) {
#line 193 "src/lib.rs"
                                          
            return p->read_bytes(offset, buf_len, buf);
        
}
extern "C" {
void __cpp_closure_14131938600352405202(FileWrapper* const& p, uint64_t const& offset, uint64_t const& buf_len, uint8_t* const& buf, void* __result) {
    ::new(__result) (uint64_t)(__cpp_closure_14131938600352405202_impl(p, offset, buf_len, buf));
}
}
#line 265 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

static inline uint64_t __cpp_closure_9646768266950418268_impl(FileWrapper* const& p) {
#line 201 "src/lib.rs"
                                                                
            return p->file.size();
        
}
extern "C" {
void __cpp_closure_9646768266950418268(FileWrapper* const& p, void* __result) {
    ::new(__result) (uint64_t)(__cpp_closure_9646768266950418268_impl(p));
}
}
#line 246 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

extern "C" {
void __cpp_closure_17329837106178068329(FileWrapper* const& p) {
#line 212 "src/lib.rs"
                                           
            delete p;
        
}
}
#line 265 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"

static inline FileWrapper* __cpp_closure_8726866203393050723_impl(FileWrapper* const& p) {
#line 223 "src/lib.rs"
                                                                                  
            return new FileWrapper(*p);
        
}
extern "C" {
void __cpp_closure_8726866203393050723(FileWrapper* const& p, void* __result) {
    ::new(__result) (FileWrapper*)(__cpp_closure_8726866203393050723_impl(p));
}
}
#line 326 "C:\\Users\\devta\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\cpp_build-0.5.4\\src\\lib.rs"


namespace rustcpp {

template<typename T>
struct AlignOf {
    struct Inner {
        char a;
        T b;
    };
    static const uintptr_t value = sizeof(Inner) - sizeof(T);
};

template<typename T>
struct Flags {
    static const uintptr_t value =
        (std::is_copy_constructible<T>::value << 0) |
        (std::is_default_constructible<T>::value << 1) |
#if !defined(__GNUC__) || (__GNUC__ + 0 >= 5) || defined(__clang__)
        (std::is_trivially_destructible<T>::value << 2) |
        (std::is_trivially_copyable<T>::value << 3) |
        (std::is_trivially_default_constructible<T>::value << 4) |
#endif
        0;
};

struct SizeAlign {
    uint64_t hash;
    uint64_t size;
    uint64_t align;
    uint64_t flags;
};

struct MetaData {
    uint8_t magic[128];
    uint8_t version[16];
    uint64_t length;
    SizeAlign data[19];
};

MetaData
#ifdef _WIN32
    __declspec (selectany)
#elif __GNUC__
    __attribute__((weak))
#endif
    metadata = {
    { 114, 117, 115, 116, 99, 112, 112, 126, 109, 101, 116, 97, 100, 97, 116, 97, 92, 74, 112, 213, 165, 185, 214, 120, 179, 17, 185, 25, 182, 253, 82, 118, 148, 29, 139, 208, 59, 153, 78, 137, 230, 54, 26, 177, 232, 121, 132, 166, 44, 106, 218, 57, 158, 33, 69, 32, 54, 204, 123, 226, 99, 117, 60, 173, 112, 61, 56, 174, 117, 141, 126, 249, 79, 159, 6, 119, 2, 129, 147, 66, 135, 136, 212, 252, 231, 105, 239, 91, 96, 232, 113, 94, 164, 255, 152, 144, 64, 207, 192, 90, 225, 171, 59, 154, 60, 2, 0, 191, 114, 182, 38, 134, 134, 183, 212, 227, 31, 217, 12, 5, 65, 221, 150, 59, 230, 96, 73, 62 },
    "0.5.4",
    19,
    { {
                9843562945469222702ull,
                sizeof(DiscWrapper*),
                rustcpp::AlignOf<DiscWrapper*>::value,
                rustcpp::Flags<DiscWrapper*>::value | 0ull << 32
            }, {
                9843562945469222702ull,
                sizeof(nod::SystemChar*),
                rustcpp::AlignOf<nod::SystemChar*>::value,
                rustcpp::Flags<nod::SystemChar*>::value
            }, {
                9843562945469222702ull,
                sizeof(const char **),
                rustcpp::AlignOf<const char **>::value,
                rustcpp::Flags<const char **>::value
            }, {
                2166181833509409529ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value | 0ull << 32
            }, {
                2166181833509409529ull,
                sizeof(DiscWrapper*),
                rustcpp::AlignOf<DiscWrapper*>::value,
                rustcpp::Flags<DiscWrapper*>::value
            }, {
                2166181833509409529ull,
                sizeof(const char*),
                rustcpp::AlignOf<const char*>::value,
                rustcpp::Flags<const char*>::value
            }, {15079480375502973842ull, 0, 1, 0ull << 32}, {
                15079480375502973842ull,
                sizeof(DiscWrapper*),
                rustcpp::AlignOf<DiscWrapper*>::value,
                rustcpp::Flags<DiscWrapper*>::value
            }, {
                14131938600352405202ull,
                sizeof(uint64_t),
                rustcpp::AlignOf<uint64_t>::value,
                rustcpp::Flags<uint64_t>::value | 0ull << 32
            }, {
                14131938600352405202ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value
            }, {
                14131938600352405202ull,
                sizeof(uint64_t),
                rustcpp::AlignOf<uint64_t>::value,
                rustcpp::Flags<uint64_t>::value
            }, {
                14131938600352405202ull,
                sizeof(uint64_t),
                rustcpp::AlignOf<uint64_t>::value,
                rustcpp::Flags<uint64_t>::value
            }, {
                14131938600352405202ull,
                sizeof(uint8_t*),
                rustcpp::AlignOf<uint8_t*>::value,
                rustcpp::Flags<uint8_t*>::value
            }, {
                9646768266950418268ull,
                sizeof(uint64_t),
                rustcpp::AlignOf<uint64_t>::value,
                rustcpp::Flags<uint64_t>::value | 0ull << 32
            }, {
                9646768266950418268ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value
            }, {17329837106178068329ull, 0, 1, 0ull << 32}, {
                17329837106178068329ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value
            }, {
                8726866203393050723ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value | 0ull << 32
            }, {
                8726866203393050723ull,
                sizeof(FileWrapper*),
                rustcpp::AlignOf<FileWrapper*>::value,
                rustcpp::Flags<FileWrapper*>::value
            } }
};

} // namespace rustcpp
